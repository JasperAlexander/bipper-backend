package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.21 DO NOT EDIT.

import (
	"bipper-backend/database"
	"bipper-backend/graph/model"
	"bipper-backend/models"
	"context"
	"fmt"
	"log"

	"github.com/thanhpk/randstr"
)

// User is the resolver for the user field.
func (r *beepResolver) User(ctx context.Context, obj *models.Beep) (*models.User, error) {
	if obj.UserID != "" {
		return db.FindUserByID(obj.UserID), nil
	} else {
		return &models.User{}, nil
	}
}

// Conversation is the resolver for the conversation field.
func (r *beepResolver) Conversation(ctx context.Context, obj *models.Beep) (*models.Beep, error) {
	if obj.ConversationID != "" {
		return db.FindBeepByID(obj.ConversationID), nil
	} else {
		return &models.Beep{}, nil
	}
}

// Reference is the resolver for the reference field.
func (r *beepResolver) Reference(ctx context.Context, obj *models.Beep) (*models.Beep, error) {
	if obj.ReferenceID != "" {
		return db.FindBeepByID(obj.ReferenceID), nil
	} else {
		return &models.Beep{}, nil
	}
}

// CreateUser is the resolver for the createUser field.
func (r *mutationResolver) CreateUser(ctx context.Context, input model.CreateUser) (*models.User, error) {
	return db.SaveUser(input), nil
}

// CreateBeep is the resolver for the createBeep field.
func (r *mutationResolver) CreateBeep(ctx context.Context, input model.CreateBeep) (*models.Beep, error) {
	// Server stops working with code below
	// addedBeep := model.AddedBeep{
	// 	Text: input.Text,
	// }

	// for _, ch := range r.addedBeepChannel {
	// 	ch <- &addedBeep
	// }

	return db.SaveBeep(input), nil
}

// UpdateBeep is the resolver for the updateBeep field.
func (r *mutationResolver) UpdateBeep(ctx context.Context, input model.UpdateBeep) (*models.Beep, error) {
	return db.UpdateBeep(input), nil
}

// UpdateBeepMetrics is the resolver for the updateBeepMetrics field.
func (r *mutationResolver) UpdateBeepMetrics(ctx context.Context, input model.UpdateBeepMetrics) (*models.Beep, error) {
	return db.UpdateBeepMetrics(input), nil
}

// GetUserByID is the resolver for the getUserByID field.
func (r *queryResolver) GetUserByID(ctx context.Context, id string) (*models.User, error) {
	return db.FindUserByID(id), nil
}

// GetUserByUsername is the resolver for the getUserByUsername field.
func (r *queryResolver) GetUserByUsername(ctx context.Context, username string) (*models.User, error) {
	log.Printf("inside schema resolvers")
	return db.FindUserByUsername(username), nil
}

// GetAllUsers is the resolver for the getAllUsers field.
func (r *queryResolver) GetAllUsers(ctx context.Context, first *int, last *int, after *string, before *string) (*model.UserConnection, error) {
	allUsers := db.AllUsers()

	a := make([]models.User, 0, len(allUsers))
	for _, edge := range allUsers {
		e := *edge
		a = append(a, e)
	}

	nodes, err := EdgesToReturn(a, before, after, first, last)
	if err != nil {
		log.Fatalf("error: %v", err)
	}

	edges := make([]models.User, 0, len(nodes))
	for _, v := range nodes {
		edges = append(edges, v.(models.User))
	}

	hasNextPage, err := HasNextPage(a, before, after, first, last)
	if err != nil {
		log.Fatalf("error: %v", err)
	}
	hasPreviousPage, err := HasPreviousPage(a, before, after, first, last)
	if err != nil {
		log.Fatalf("error: %v", err)
	}
	var startCursor, endCursor string
	if len(edges) > 0 {
		startCursor = string(edges[0].ID)
		endCursor = string(edges[len(edges)-1].ID)
	}
	pageInfo := model.PageInfo{
		HasNextPage:     hasNextPage,
		HasPreviousPage: hasPreviousPage,
		StartCursor:     &startCursor,
		EndCursor:       &endCursor,
	}

	userEdges := make([]*model.UserEdge, 0, len(edges))
	for _, edge := range edges {
		userEdges = append(userEdges, ToUserEdgeResponse(&edge))
	}

	userConnection := ToUserConnectionResponse(userEdges, &pageInfo)

	return userConnection, nil
}

// GetBeepByID is the resolver for the getBeepByID field.
func (r *queryResolver) GetBeepByID(ctx context.Context, id string) (*models.Beep, error) {
	return db.FindBeepByID(id), nil
}

// GetAllBeeps is the resolver for the getAllBeeps field.
func (r *queryResolver) GetAllBeeps(ctx context.Context, first *int, last *int, after *string, before *string) (*model.BeepConnection, error) {
	allBeeps := db.AllBeeps()

	a := make([]models.Beep, 0, len(allBeeps))
	for _, edge := range allBeeps {
		e := *edge
		a = append(a, e)
	}

	nodes, err := EdgesToReturn(a, before, after, first, last)
	if err != nil {
		log.Fatalf("error: %v", err)
	}

	edges := make([]models.Beep, 0, len(nodes))
	for _, v := range nodes {
		edges = append(edges, v.(models.Beep))
	}

	hasNextPage, err := HasNextPage(a, before, after, first, last)
	if err != nil {
		log.Fatalf("error: %v", err)
	}
	hasPreviousPage, err := HasPreviousPage(a, before, after, first, last)
	if err != nil {
		log.Fatalf("error: %v", err)
	}
	var startCursor, endCursor string
	if len(edges) > 0 {
		startCursor = string(edges[0].ID)
		endCursor = string(edges[len(edges)-1].ID)
	}
	pageInfo := model.PageInfo{
		HasNextPage:     hasNextPage,
		HasPreviousPage: hasPreviousPage,
		StartCursor:     &startCursor,
		EndCursor:       &endCursor,
	}

	beepEdges := make([]*model.BeepEdge, 0, len(edges))
	for _, edge := range edges {
		beepEdges = append(beepEdges, ToBeepEdgeResponse(&edge))
	}

	beepConnection := ToBeepConnectionResponse(beepEdges, &pageInfo)

	return beepConnection, nil
}

// GetAllBeepsByUserUsername is the resolver for the getAllBeepsByUserUsername field.
func (r *queryResolver) GetAllBeepsByUserUsername(ctx context.Context, username string, first *int, last *int, after *string, before *string) (*model.BeepConnection, error) {
	allBeeps := db.AllBeepsOfUserByUsername(username)

	a := make([]models.Beep, 0, len(allBeeps))
	for _, edge := range allBeeps {
		e := *edge
		a = append(a, e)
	}

	nodes, err := EdgesToReturn(a, before, after, first, last)
	if err != nil {
		log.Fatalf("error: %v", err)
	}

	edges := make([]models.Beep, 0, len(nodes))
	for _, v := range nodes {
		edges = append(edges, v.(models.Beep))
	}

	hasNextPage, err := HasNextPage(a, before, after, first, last)
	if err != nil {
		log.Fatalf("error: %v", err)
	}
	hasPreviousPage, err := HasPreviousPage(a, before, after, first, last)
	if err != nil {
		log.Fatalf("error: %v", err)
	}
	var startCursor, endCursor string
	if len(edges) > 0 {
		startCursor = string(edges[0].ID)
		endCursor = string(edges[len(edges)-1].ID)
	}
	pageInfo := model.PageInfo{
		HasNextPage:     hasNextPage,
		HasPreviousPage: hasPreviousPage,
		StartCursor:     &startCursor,
		EndCursor:       &endCursor,
	}

	beepEdges := make([]*model.BeepEdge, 0, len(edges))
	for _, edge := range edges {
		beepEdges = append(beepEdges, ToBeepEdgeResponse(&edge))
	}

	beepConnection := ToBeepConnectionResponse(beepEdges, &pageInfo)

	return beepConnection, nil
}

// BeepAdded is the resolver for the beepAdded field.
func (r *subscriptionResolver) BeepAdded(ctx context.Context) (<-chan *model.AddedBeep, error) {
	token := randstr.Hex(16)
	ch := make(chan *model.AddedBeep, 1)
	r.addedBeepChannel[token] = ch

	go func() {
		for {
			// Possible: set timer
			// time.Sleep(4 * time.Second)
			// fmt.Println("Tick")
			select {
			// case ch <- "Tick": // This is the actual send.
			default: // This is run when our send does not work.
				fmt.Println("Channel closed.")
				return
			}
		}
	}()

	return ch, nil
}

// PinnedBeep is the resolver for the pinnedBeep field.
func (r *userResolver) PinnedBeep(ctx context.Context, obj *models.User) (*models.Beep, error) {
	if obj.PinnedBeepID != "" {
		return db.FindBeepByID(obj.PinnedBeepID), nil
	} else {
		return &models.Beep{}, nil
	}
}

// Beep returns BeepResolver implementation.
func (r *Resolver) Beep() BeepResolver { return &beepResolver{r} }

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Subscription returns SubscriptionResolver implementation.
func (r *Resolver) Subscription() SubscriptionResolver { return &subscriptionResolver{r} }

// User returns UserResolver implementation.
func (r *Resolver) User() UserResolver { return &userResolver{r} }

type beepResolver struct{ *Resolver }
type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type subscriptionResolver struct{ *Resolver }
type userResolver struct{ *Resolver }

// !!! WARNING !!!
// The code below was going to be deleted when updating resolvers. It has been copied here so you have
// one last chance to move it out of harms way if you want. There are two reasons this happens:
//  - When renaming or deleting a resolver the old code will be put in here. You can safely delete
//    it when you're done.
//  - You have helper methods in this file. Move them out to keep these resolver files clean.
var db = database.Connect()
